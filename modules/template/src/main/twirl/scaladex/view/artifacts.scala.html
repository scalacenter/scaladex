@import scaladex.core.model.{Artifact, Platform, Project, SemanticVersion, UserState, Env}

@(
  env: Env,
  project: Project,
  user: Option[UserState],
  targetTypesWithVersion: Map[Platform.PlatformType, Seq[String]],
  semanticVersionWithArtifacts: Seq[(SemanticVersion, Map[Artifact.Name, Seq[(Artifact, String)]])]
)
@allScalaVersions= @{targetTypesWithVersion.values.flatten}

@main(env, title = project.repository.toString, showSearch = true, user) {
  <main class="artifacts">
    <div class="row">
      <div class="col-md-12">
        <a href="/@project.organization/@project.repository" class="btn btn-primary">
          Back
        </a>
      </div>
    </div>

    <div class="row">
      <div class="col-md-12">

    <table>
      <thead>
        <tr>
          <th rowspan="2" class="version">Versions</th>
          <th rowspan="2" class="artifact">Artifacts</th>

          @targetTypesWithVersion.map { case (targetType, versions) =>
            <th colspan="@{versions.size}">
              <label>
                <input type="checkbox" name="targetType" value="supported-target-type_@targetType"
                       onclick="ScaladexClient.updateVisibleArtifactsInGrid()">
                @targetType
              </label>
            </th>
          }
        </tr>
        <tr>
          @allScalaVersions.map { version =>
            <th class="target">
              <label>
                <input type="checkbox" name="target" value="supported-scala-version_@version"
                       onclick="ScaladexClient.updateVisibleArtifactsInGrid()">
                @version
              </label>
            </th>
          }
        </tr>
      </thead>

      @semanticVersionWithArtifacts.map { case (semanticVersion, artifactsByName) =>
      <tbody class="version-line version-line-visible">
            <tr>
              <td rowspan="@{artifactsByName.size + 1}" class="version">
                @semanticVersion
              </td>
            </tr>
            @artifactsByName.map { case (artifactName, artifactsAndScalaVersion) =>
              @defining(artifactsAndScalaVersion.map(_._2)) { scalaVersions =>
              @defining(artifactsAndScalaVersion.map(_._1)) { artifacts =>
              @defining( targetTypesWithVersion.filter { case (targetType, sVersions) =>
                sVersions.intersect(scalaVersions).nonEmpty }.keys){ targetTypes =>
                  <tr class="@({ if (targetTypes.isEmpty) { "" }
                  else {
                    ("artifact-line artifact-line-visible") +
                      targetTypes.toList.distinct.map(" supported-target-type_" + _).mkString(" ") +
                      scalaVersions.map(" supported-scala-version_" + _).mkString(" ")
                  }
                     })">
                    <td class="artifact">
                      @artifactName
                    </td>
                    @allScalaVersions.map { version =>
                      <td class="target" title="@version">
                        @if(scalaVersions.contains(version)) {
                          <a href="@artifacts.headOption.map(_.httpUrl).getOrElse("")" class="supported-target"></a>
                        }
                      </td>
                    }
                  }
                </tr>
              }
            }
          }
        </tbody>
        }
    </table>

      </div>
    </div>
  </main>

  <script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function() {
    ScaladexClient.updateVisibleArtifactsInGrid();
  })
  </script>
}
